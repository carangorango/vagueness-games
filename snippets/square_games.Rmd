
``` {r warning=FALSE, message=FALSE, echo=FALSE}

require('gtools') # for dirichlet distribution
require('ggplot2')
require('reshape2')
require('fpc') # for function pamk(.) -> wrapper for kmeans!
source('~/Desktop/data/svn/programming/R/fuzzy-action/dev.r') # for basic sim-max operations (get.eu.s etc.)
```

Square Games
------------

A square game is a sim-max game with 4 states in a two dimensional similarity space. States are situated at coordinates (0,0), (0,x), (x,0) and (x,x) where x > 0. The distance between these states is given by the geometrical distance.


```{r}
x = 1
D = matrix(c(0,x,x,sqrt(2)*x,
             x,0,sqrt(2)*x,x,
             x,sqrt(2)*x,0,x,
             sqrt(2)*x,x,x,0),nrow=4, byrow=T)
show(D)
```


The (Nosofsky-)utility of these with parameter a is:

```{r}
a = 20
U = D
for (i in 1:4){
  for (j in 1:4){
    U[i,j] = exp(- (D[i,j]^2)/(a^2))
  }
}
show(U)
```

What matters to the utility table is the proportion between x and a, so we can better express the game with respect to a single parameter k=x/a. But we can then also think of x as fixed to x=1, so that a is our only parameter.

There are two messages in these games.

Equilibria
----------

There are two types of equilibria whose sender strategy partitions the state space. 

* In *diagonal equilibria*, the sender uses one message for states 1 and 4, and another for 2 and 3. These are the states that are most dissimilar to each other. 
* In *convex equilibria*, the sender uses one message for two adjacent states, thereby partitioning the state space into convex regions.

Neither of these are strict, because the receiver can respond with different act to either message.

There are 4 diagonal equilibria, and 8 convex equilibria.

Convex equilibria are more efficient than diagonal equilibria. 

We are interested in the basins of attraction of these under the replicator diffusion dynamic. 

Replicator Dynamic
------------------

We run several trials of the (discrete-time) replicator dynamic to find out which attracting states exist.

```{r}
trials = 100
rounds = 100000
break.point = 0.0000001


ns = dim(U)[1]
nm = 2

priors = rep(1/ns,ns)
costs = matrix(rep(0,nm*ns),nrow=ns)

P = matrix(0,ncol=2*ns*nm+1,nrow=trials)
colnames(P) = c("S(t1,m1)", "S(t2,m1)", "S(t3,m1)", "S(t4,m1)",
                "S(t1,m2)", "S(t2,m2)", "S(t3,m2)", "S(t4,m2)",
                "R(m1,t1)", "R(m2,t1)", "R(m1,t2)", "R(m2,t2)",
                "R(m1,t3)", "R(m2,t3)", "R(m1,t4)", "R(m2,t4)",
                "EU")

for (t in 1:trials){
  
  setTxtProgressBar(pb, t)
  
  sen = rdirichlet(ns,rep(1/nm,nm))
  rec = rdirichlet(nm,rep(1/ns,ns))
  
  for (round in 1:rounds){
    
    s = sen
    r = rec
    
    eu.s = get.eu.s(rec ,U)
    eu.r = get.eu.r(sen,utils=U,priors=priors) 
    
    sen = prop.table( sen * eu.s ,1)
    rec = prop.table( rec * eu.r ,1)
    
    if (sum(abs(sen-s)) <= break.point & sum(abs(rec-r)) <= break.point){
      break()
    }
  }
  eu = get.eu(priors,U,sen,rec,costs)
  P[t,] = c(as.vector(c(sen, rec)),eu)
}

P = P[,c(1:8,9,11,13,15,10,12,14,16,17)]

```

Show results:

```{r}
X = round(P,4)
Y = pamk(X,krange=2:22)
show(table(Y$pamobject$clustering))
show(Y$pamobject$medoids)
```









