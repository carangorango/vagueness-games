Data Exploration
================

``` {r warnings=FALSE, message=FALSE, echo=FALSE}

require('ellipse')
require('ggplot2')
require('reshape2')
require('plyr')
source('~/Desktop/data/svn/programming/R/helpers/helpers.R')
source('~/Desktop/data/svn/vagueness-games/data-analysis.R')

data = read.csv('~/Desktop/data/svn/vagueness-games/results/20140918-142408.varTolerance.csv', 
                colClasses=c('numeric','factor','numeric','numeric','numeric',
                             'factor','numeric','numeric','numeric','numeric',
                             'numeric','numeric','numeric','numeric','numeric',
                             'numeric','numeric','numeric','character','character'))

# no idea why these numbers are messed up, but this fix seems to solve it
data$Speaker.Voronoiness = ifelse(data$Speaker.Voronoiness > 1, 
                                  yes = data$Speaker.Voronoiness / 1000, 
                                  no = data$Speaker.Voronoiness)
data$Hearer.Voronoiness = ifelse(data$Hearer.Voronoiness > 1, 
                                  yes = data$Hearer.Voronoiness / 1000, 
                                  no = data$Hearer.Voronoiness)

ds = data[,c(1,4,5,7,8,11:17)] # only relevant data
dm = melt(ds,id.vars = c("Number.of.states", "Impairment", "Tolerance")) # melted data

attach(ds)

plot.language.byindex = function(dataFrame,rowindex){
  plot.language(dataFrame[rowindex,]$Speaker.strategy.file,
                dataFrame[rowindex,]$Hearer.strategy.file)
}

plot.language.MinMaxProperty = function(dataFrame,colindex){
  show(names(dataFrame)[colindex])
  show(summary(dataFrame[,colindex]))
  p = arrangeGrob(plot.language.byindex(dataFrame,which.min(dataFrame[,colindex])),
                  plot.language.byindex(dataFrame,which.max(dataFrame[,colindex])))
}

```

plot all the relevant variables against each other

``` {r warning = FALSE, fig.width=12, fig.height=12}

pairs(~ Number.of.states + Impairment + Tolerance + Speaker.entropy + Hearer.entropy + 
        Speaker.Voronoiness + Hearer.Voronoiness +
        Speaker.informativity + Hearer.informativity + Expected.utility + Iterations +
        Speaker.Convex.Cat, data=ds)
```

some properties are very clearly positively correlated:

* speaker informativity, hearer informativity & expected utility
* impairment & speaker entropy

these two "clusters" are also strongly negatively correlated

``` {r warning = FALSE, fig.width=7, fig.height=7}

dss = ds[c("Impairment", "Speaker.informativity", "Hearer.informativity", "Expected.utility",
           "Speaker.entropy")]

ctab <- cor(dss)

plotcorr(ctab)

```


Replotting data for each combination of values of independent variables
-----------------------------------------------------------------------

We have three independent variables: impairment, tolerance & number of states. The following plots show the means of all 50 data points for each combination of values for independent variables, together with the estimated confidence intervals.

```{r message=FALSE, warning=FALSE, fig.width=10, fig.height=10}

dms = summarySE(dm, groupvars = c("Number.of.states", "Impairment", "Tolerance", "variable"), measurevar="value")
dsub = dms

pd <- position_dodge(.01)
sp = ggplot(dsub, aes(x=Impairment, y=value, colour=factor(Number.of.states))) + 
     geom_point(position = pd) +
     geom_errorbar(aes(ymin=value-ci, ymax=value+ci), width=0, position=pd) +
     geom_line(position=pd) 

sp + facet_grid(variable ~ Tolerance, scales="free")

```

Informativity
-------------

This is the notion from Skyrms. It seems very well-behaved. There is a clear positive correlation between speaker and hearer informativity.

```{r fig.width=5, fig.height=5}
cor.test(data$Speaker.informativity, data$Hearer.informativity)
qplot(data$Speaker.informativity, data$Hearer.informativity) + geom_smooth(method=lm)
```

There is a clear negative correlation between impairment and informativity. The remaining variance here must and can be accounted for in terms of Number.of.states (see main plot).

```{r fig.width=5, fig.height=5}
cor.test(data$Impairment, data$Speaker.informativity)
qplot(data$Impairment, data$Speaker.informativity) + geom_smooth(method=lm)
```


How much identity in outcomes?
------------------------------

It turns out that there is surprisingly little variance in the recorded values of dependent variables, at least for some triples of independent variables (tolerance, impairment, number of states). We can plot the difference between the maximmal and the minimal value of each property for each triplet of independent variables.

```{r message=FALSE, warning=FALSE, fig.width=10, fig.height=10}

dm = melt(subset(ds,Iterations < 205)[,-which(names(ds) == "Iterations")],
          id.vars = c("Number.of.states", "Impairment", "Tolerance")) # melted data

MinMaxProperty = ddply(dm, .(Number.of.states, Impairment, Tolerance, variable), 
                      summarise, 
                      MaxMinDiff = max(value) - min(value),
                      MinProperty = min(value), MaxProperty = max(value), MeanProperty = mean(value))

pd <- position_dodge(.01)
sp = ggplot(MinMaxProperty, aes(x=Impairment, y=MaxMinDiff, colour=factor(Number.of.states))) + 
     geom_point(position = pd)

sp + facet_grid(variable ~ Tolerance, scales="free")
```

We can then look at the maximal difference among all properties. (This works because all relevant dependent measures scale inbetween 0 and 1.)

```{r}
diffTrials = ddply(MinMaxProperty,
                   .(Number.of.states, Impairment, Tolerance), 
                  summarise, 
                  diffTrials = max(MaxMinDiff) <=1e-5,
                  maxDiffTrials = max(MaxMinDiff) )

ggplot(diffTrials, aes(x=Impairment, y=maxDiffTrials, )) + 
     geom_point() + facet_grid(Number.of.states ~ Tolerance, scales="free")



```

We see clearly that, all else equal (e.g. fixed tolerance and number of states), impairment 'unifies' evolutionary outcomes. When impairment is at least 0.1, outcomes are all almost identical (in terms of the recorded properties).

Notice that this 'uniformity' is different from just convexity vs. non-convexity!

```{r message=FALSE, warning=FALSE, fig.width=5, fig.height=5}

d = subset(dsub, dsub$variable =="Speaker.Convex.Cat")

pd <- position_dodge(.01)
sp = ggplot(d, aes(x=Impairment, y=1-value )) + 
     geom_point(position = pd)

sp + facet_grid(Number.of.states ~ Tolerance, scales="free")

```

There are strategies whose speaker strategies are all convex (e.g. for ns = 6, tolerance = 0.3 and impairment = 0.05), but whose other properties differ. Here are two strategies from that class of independent variable values that differ maximally in terms of expected utility.

```{r message=FALSE, warning=FALSE, fig.width=7, fig.height=7}

d = subset(data, Number.of.states == 6 & Tolerance == 0.3 &
             Impairment == 0.05 & Speaker.Convex.Cat == 1)

show(plot.language.MinMaxProperty(d, which(names(d) == "Expected.utility")))

```

In contrast, if we look at a "uniform" class of independent parameter values, such as with ns = 50, tolerance = 0.1, impairment = 0.1, then the strategies whose EU are minimal and or maximal in that class don't differ optically at all (modulo arbitrariness of message use).

```{r message=FALSE, warning=FALSE, fig.width=7, fig.height=7}

d = subset(data, Number.of.states == 50 & Tolerance == 0.1 &
             Impairment == 0.1)

show(plot.language.MinMaxProperty(d, which(names(d) == "Expected.utility")))

```

What this suggests is that the differences in some of the groups might be due to non-evenly splitting the interval. Impairment leads to even splits and therefore to uniformity of evolutionary outcomes.