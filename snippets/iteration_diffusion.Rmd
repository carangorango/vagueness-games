```{r warning=FALSE, echo=FALSE, message=FALSE}
library(MCMCpack) # for Dirichlet distribution
source('~/Desktop/data/svn/programming/R/fuzzy-action/dev.r')
```


(Iterated) Diffusion
==================

The (discrete) Replicator Diffusion Dynamic first calculates the replicator dynamic and then applies diffusion, so to speak. To understand what diffusion does, we'd like to see it run without the replicator dynamics. 

Two things are interesting: (1) what does diffusion do in one step, (2) what does it do in iteration.

We must look at the sender and the receiver roles seperately.

Preliminaries & Parameters
--------------------------

```{r}
alpha= 0.1
rounds = 10000
ns = 11
nm = 3
states = seq(from=0,to=1,length.out = ns)
C = get.confusion.matrix(states,alpha)
```

Diffusion
---------

Diffusion is defined as simple matrix product for sender and receiver strategies.

```{r}

get.nbr = function(response,noise.matrix){
    if (dim(noise.matrix)[1] == dim(response)[2]){  # receiver part
        return(response %*% noise.matrix)
    }
    if (dim(noise.matrix)[2] == dim(response)[1]){  # sender part
        return(noise.matrix %*% response)
    }
}

```

But that means that we can define iterated diffusion as either left or right multiplication with suitable powers of the confusion matrix. Therefore define a the n-th power of the confusion matrix.

```{r}
power = function(C,n){
  # this could be improved for speed
  if (n <=1){
    return(C)
  }
  else{
    if (n %% 2 ==0){
      X = power(C,n/2)
      return(X%*%X)
    }
    else{
      return(C%*%power(C,n-1))
    }
  }
}
```


Iterated Diffusion
------------------

Create an arbitrary sender and receiver strategy, and iterate the diffusion process.

```{r}

sen = rdirichlet(ns,rep(1,nm))
rec = rdirichlet(nm,rep(1,ns))

CPower = power(C,rounds)
show(CPower)

sen = CPower %*% sen
show(sen)

rec = rec %*% CPower  
show(rec)

```



