```{r warning=FALSE, echo=FALSE, message=FALSE}
library(MCMCpack) # for Dirichlet distribution
source('~/Desktop/data/svn/programming/R/fuzzy-action/dev.r')
```


Iterated Diffusion
==================

The (discrete) Replicator Diffusion Dynamics first calculates the replicator dynamics and then applies diffusion, so to speak. To understand what diffusion does, we'd like to see it run without the replicator dynamics. We look at the sender and the receiver roles seperately.

Preliminaries & Parameters
--------------------------

```{r}

alpha= 0.2
rounds = 1000
ns = 7
nm = 4
states = seq(from=0,to=1,length.out = ns)
C = get.confusion.matrix(states,alpha)
```

Diffusion
---------

Diffusion is defined as simple matrix product for sender and receiver strategies.

```{r}

get.nbr = function(response,noise.matrix){
    if (dim(noise.matrix)[1] == dim(response)[2]){  # receiver part
        return(response %*% noise.matrix)
    }
    if (dim(noise.matrix)[2] == dim(response)[1]){  # sender part
        return(noise.matrix %*% response)
    }
}

```

Iterated Diffusion
------------------

Create an arbitrary sender and receiver strategy, and iterate the diffusion process.

```{r}

sen = rdirichlet(ns,rep(1,nm))
rec = rdirichlet(nm,rep(1,ns))

for (i in 1:rounds){
  sen = get.nbr(sen,C)
  rec = get.nbr(rec,C)
}

show(rec)
show(sen)


```



